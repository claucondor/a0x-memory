"""
Core Data Structure - MemoryEntry (Atomic Entry)

Paper Reference: Section 3.1 - Atomic Entries {m_k}
Each MemoryEntry represents a self-contained, disambiguated fact extracted
from dialogue via the De-linearization transformation F_θ

Extended for Group Support:
- Platform context (telegram, xmtp, farcaster, twitter, direct)
- Group ID for group conversations
- User identity linking
- Memory classification (expertise, preference, fact, etc.)
- Privacy scoping
"""
from typing import List, Optional
from pydantic import BaseModel, Field
from enum import Enum
import uuid


class MemoryType(str, Enum):
    """Type of memory content - for classification and retrieval"""
    CONVERSATION = "conversation"  # General conversation
    EXPERTISE = "expertise"        # User skill/knowledge
    PREFERENCE = "preference"      # User preference/interest
    FACT = "fact"                  # Factual information about user
    ANNOUNCEMENT = "announcement"  # Group announcement/decision


class PrivacyScope(str, Enum):
    """Privacy scope for access control"""
    PRIVATE = "private"           # Only agent can see (DMs)
    GROUP_ONLY = "group_only"     # Only visible in this group
    PUBLIC = "public"             # Cross-group visible


class MemoryEntry(BaseModel):
    """
    Atomic Entry - Self-contained memory unit indexed across three orthogonal layers

    Paper Reference: Section 3.1 - Eq. (3), (4)
    Generated by De-linearization: m_k = F_θ(W_t) = Φ_time ∘ Φ_coref ∘ Φ_extract(W_t)
    Indexed via: M(m_k) = {v_k (semantic), h_k (lexical), R_k (symbolic)}
    """
    entry_id: str = Field(default_factory=lambda: str(uuid.uuid4()))

    # [Semantic Layer] - Dense embedding base (v_k = E_dense(S_k))
    lossless_restatement: str = Field(
        ...,
        description="Self-contained fact with Φ_coref (no pronouns) and Φ_time (absolute timestamps)"
    )

    # [Lexical Layer] - Sparse keyword vectors (h_k = Sparse(S_k))
    keywords: List[str] = Field(
        default_factory=list,
        description="Core keywords for BM25-style exact matching"
    )

    # [Symbolic Layer] - Metadata constraints (R_k = {(key, val)})
    timestamp: Optional[str] = Field(
        None,
        description="Standardized time in ISO 8601 format (YYYY-MM-DDTHH:MM:SS)"
    )
    location: Optional[str] = Field(
        None,
        description="Natural language location description"
    )
    persons: List[str] = Field(
        default_factory=list,
        description="List of extracted persons"
    )
    entities: List[str] = Field(
        default_factory=list,
        description="List of extracted entities (companies, products, etc.)"
    )
    topic: Optional[str] = Field(
        None,
        description="Topic phrase summarized by LLM"
    )

    # ─── GROUP CONTEXT (NEW) ───
    group_id: Optional[str] = Field(
        None,
        description="Group identifier (None = DM, 'telegram_-123456' = group)"
    )
    user_id: Optional[str] = Field(
        None,
        description="User identifier ('telegram:123456789')"
    )
    username: Optional[str] = Field(
        None,
        description="Username/handle ('@alice')"
    )
    platform: str = Field(
        default="direct",
        description="Platform: telegram, xmtp, farcaster, twitter, direct"
    )

    # ─── MEMORY CLASSIFICATION (NEW) ───
    memory_type: MemoryType = Field(
        default=MemoryType.CONVERSATION,
        description="Type of memory for retrieval optimization"
    )
    privacy_scope: PrivacyScope = Field(
        default=PrivacyScope.PRIVATE,
        description="Privacy scope for access control"
    )
    importance_score: float = Field(
        default=0.5,
        ge=0.0,
        le=1.0,
        description="Importance score 0-1 (higher = more important)"
    )
    is_shareable: bool = Field(
        default=False,
        description="Can this memory be shared to other contexts (groups, cross-context)?"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "entry_id": "550e8400-e29b-41d4-a716-446655440000",
                "lossless_restatement": "Alice discussed the marketing strategy for new product XYZ with Bob at Starbucks in Shanghai on November 15, 2025 at 14:30.",
                "keywords": ["Alice", "Bob", "product XYZ", "marketing strategy", "discussion"],
                "timestamp": "2025-11-15T14:30:00",
                "location": "Starbucks, Shanghai",
                "persons": ["Alice", "Bob"],
                "entities": ["product XYZ"],
                "topic": "Product marketing strategy discussion"
            }
        }


class Dialogue(BaseModel):
    """
    Original dialogue entry with platform and group context.

    Extended to carry all context needed for MemoryBuilder to decide
    what type of memory to create and how to classify it.
    """
    dialogue_id: int
    speaker: str
    content: str
    timestamp: Optional[str] = None  # ISO 8601 format

    # ─── PLATFORM CONTEXT (NEW) ───
    platform: str = Field(
        default="direct",
        description="Platform: telegram, xmtp, farcaster, twitter, direct"
    )
    group_id: Optional[str] = Field(
        None,
        description="Group identifier (None = DM)"
    )
    user_id: Optional[str] = Field(
        None,
        description="User identifier ('platform:id')"
    )
    username: Optional[str] = Field(
        None,
        description="Username/handle"
    )

    # ─── MESSAGE METADATA (NEW) ───
    message_id: Optional[str] = Field(
        None,
        description="Original message ID from platform"
    )
    is_reply: bool = Field(
        default=False,
        description="Is this a reply to another message"
    )
    reply_to_message_id: Optional[str] = Field(
        None,
        description="Message ID being replied to"
    )
    mentioned_users: List[str] = Field(
        default_factory=list,
        description="List of mentioned usernames"
    )

    def __str__(self) -> str:
        time_str = f"[{self.timestamp}] " if self.timestamp else ""
        speaker_str = self.username or self.speaker
        return f"{time_str}{speaker_str}: {self.content}"

    def is_group_message(self) -> bool:
        """Check if this is a group message"""
        return self.group_id is not None
